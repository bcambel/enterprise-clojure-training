Welcome to Enterprise Clojure Training, part 3: Functions.

To define a function we use the `defn` form.
`defn` followed by the name of the function and then the arguments in a vector.
In this case we are providing just one argument: `x`.
We then make use of `x` inside the function.
The last form of a function is returned as a result.
We can optionally supply a docstring to describe what the function does.
In Clojure all functions return the last expression as a result.
The effect of `defn` is to create a Var.
We created the square function and now we can call it by putting it in parens.
The square of 2 is 4.

You'll notice that mathematical operators are always expressed in prefix notation.
In Clojure functions always come at the start of the list.
The arguments of a function call are always evaluated before the function call.
In this case the square of 2 is 4, the square of 3 is 9.
The addition of 4 and 9 is 13.
Arguments are evaluated from left to right before the function is called.

You can declare unnamed functions using the `fn` form.
It is just the same as `defn` but does not create a Var.

There is also a shorthand syntax.
Using the hash at the front of
the list this is the same as this
unnamed functions are also called
anonymous functions or lambda
expressions in the same way that you
might put square in the start of our
list you can put a function directly in
the start of the list and it will be
called immediately so in this example
we're actually immediately calling this
function definition
with the argument 1 so this function
just performs an increment on its
argument an increment of 1 is 2 here's
how it would look using the special
syntax notice that the argument for the
special syntax is the percentage sign a
closure is a function that captures
values from the environment here's a let
binding where who is bound to the string
world inside this let's go we define a
function that makes use of the string
STR is a function that produces a new
string by combining its arguments so in
this case it's going to combine hello
with who which is world producing hello
world
notice that we defined the function
inside the let's go
so who was accessible outside of the
let's go palaver
we can't evaluate who if we try to
evaluate who outside of the let's go
we'd get unbound however we did create a
function we created a VAR called greet
which is a function if we call that
function it's going to return hello
world this is because the function was
defined inside the scope of whoo and so
it captured the value from the
environment and that's all the closure
is it's a function that is making use of
values from the environment this turns
out to be very useful it's also possible
to pass a function to another function
in this example we're going to pass in a
function called F and we're just going
to call F three times in a row the
result will be the last evaluation of F
because closure always returns the last
evaluation as a result so how do we make
use of this fashion for all we need to
pass it a function so we invoke it
passing in a function in this case we're
just going to print hut and so the
function gets evaluated three times and
the last result is nil because the
result of print is nil the important
thing to note from this is that
functions are values so they can be
arguments to other functions a function
that takes a function as an argument is
called a higher-order function in
closure there's a function code map it
can be a little bit confusing because
there's also a data structure called a
map but in this slide on topic talking
about the function map now the function
map takes a function as its first
argument and a sequence as its second
argument and it applies that function
over the sequence which is to say for
each element in the sequence it's going
to call this function so the increment
of one is to the increment of 2 is 3 the
increment of 3 is 4 we call this mapping
a function over a sequence the function
of course can be defined in lime using
an enormous function so in this case I'm
just going to define a function that I
want to map over this sequence right
here and the function is going to be
multiplying the single argument by
itself which is essentially taking the
square so we could have put square in
here or we can define a function in line
here it doesn't matter the point is
we're passing a function to the map
function and it's applying that over the
sequence the result is a sequence where
we squared each element in the sequence
so it's 1 4 9 16 and the key point about
this is that we don't always need to
create a global definition of a function
in order to pass a function to another
function here's another example just to
show you what it would look like if we
defined a function to use with map we
define a function and greet them that
takes in a person as a name it combines
the hello with the person's name and
returns
hello person so if we mat greet them
over a sequence of people names we get
back hello Alice hello Bob hello Carol
personally I like to lean towards
creating predefined functions I feel
that it's a little bit more readable and
easier to think about however we can
create very terse expressions if we want
to and this brings with it a lot of
expressivity using the lambda syntax
here I have defined a function that adds
X to the argument X is being captured
from the environment X is always 5 in
this case and then it just adds whatever
the argument is to that so adding 5 to 1
get 6 adding 5 to 2 is 7 and in 5 2 3 is
a this is a very compact example showing
you how you can go to mine higher-order
functions with closures to get stuff
done it turns out that using
higher-order functions and closures can
be very expressive it's also possible to
provide a name to the FN definition of
an inline function here I've assigned
the name add 1 to this function this
doesn't create a VAR like defin and so
if you try and call add 1 it says unable
to resolve this so this definition can
only be used in place where are you
going to pass a function directly or
invoke the function directly the
advantage here is that the name
documents the purpose of the function
and another benefit is that if you do
get an error and you have a stack trace
you'll actually see this name in the
stack trace so it makes a searchable
clue as to what's gone wrong if you
don't give it a name you'll just get an
anonymous function and it would be very
clear where that occurred also the
function can call itself using this name
so coming back to named functions we
already saw that we create named
functions using Devon so in this case we
define if
option F that just increments X this
turns out to just be a shorthand to
defining a VAR f to be a function this
code here is an expansion of this this
is a Defen is a macro which gets
expanded out into this code and we'll
delve into what that all means later but
the important thing to take away here is
that all functions are equivalent in
reality the named function is simply
Duffing a VAR f so that we can use it in
a global context very otic arguments is
a fancy way of saying that a function
accepts any number of inputs we can
define a function f that can take three
arguments it can take as many as we
throw it actually so we could call this
with five arguments sometimes that's
useful for instance the plus operator
there's no reason why we can't just take
as many arguments as as people want to
give us an enclosure plus can actually
take as many arguments as you want the
point of this slide is just to show you
the syntax which is that if you want to
take a variable number of arguments use
this ampersand sign and this is a
destructuring form where we're
destructuring i want a sequence of
arguments arts is going to be a sequence
so in this case you can see when we
called F with one two three we got back
this sequence one two three so if you
ever hear very attic arguments it just
means a variable number Varitek
can have some disadvantages it's not
always convenient because sometimes you
do want to apply a function to a
sequence and of course we can do that
with apply so in this example we've set
up a very attic function called bake
cakes and we can pass in cake one cake -
cake three but in the case that we
actually get a bunch of cakes out of the
database for instance we have to use a
ply to use bake cakes
that's not a huge inconvenience but it
just shows that well maybe we should
have just used a sequence as an input
instead of a very Adak function so it
depends a little bit on how the function
is going to be used in general I think
it's a good rule of thumb to prefer
functions that just do one thing because
you can always combine those with
sequence operations and what I mean by
that is in in this particular scenario I
could have just created a function that
makes a single cake and I feel that
would have actually been preferable and
in the case that I get out a bunch of
cakes from my database I can call my
function multiple times using built in
sequence operators in this case do c is
for side-effect purposes it's simply
calling the function for each each
element in the sequence so this is very
similar to Matt the difference here is
that Matt will produce a result for
everything in the sequence whereas do
seek just calls the function for its
side-effects so it does not keep the
result there is one particular very
addict pattern that you should avoid you
might see this add in closure code if
you do just be aware that it's bad style
and you shouldn't do it but it's
possible to provide a destructuring that
says I'm gonna take any number of
arguments but I'm just gonna take the
first argument so this bears a little
bit of explaining you can think of this
ampersand is saying okay I'm going to
destructor any number of arguments here
as a sequence and then we're further
destructuring that sequence we're saying
the sequence the first element is y and
then there's nothing after Y so we're
essentially ignoring everything after
the first element in the sequence
so this destructuring form is a neat
little way to get out the first element
of any number of arguments and that
seems like a great idea if you just want
to allow a function to be called with
some additional
option or something like that however it
turns out to be a bad idea to do it this
way the reason is that if I call this
function now with a whole lot of
arguments closure is just fine with that
because we're just ignoring all the
other arguments and so it'll make use of
the first two arguments here and in this
case it says if you gave me a y-value
I'm going to add x and y so and X&Y add
1 and 2 we get 3 but I think most people
would be kind of surprised that you know
if you've give it a string
it doesn't affect it in any way so a
better way to achieve the same result is
to explicitly specify what argument
lists are possible this is the way you
can express the same thing in a more
explicit way we just get one argument
we're just going to return Inc of X if
you get two arguments then we're going
to add those two arguments together so
when you do your defend form if you have
in parens these argument and then
function body argument list function
body that's a way to set up a function
that can take different amounts of
arguments but it there is an explicit
list of what's acceptable and what's not
acceptable and the good thing about this
obviously is that if you call it with
something that doesn't make sense yeah
you'll actually get an exception so you
can see that there's a problem pleasure
also supports keyword arguments I
recommend you avoid them but I want you
to see what the syntax is just so you're
aware of them so in this case we're
setting up a function f and here we've
got the ampersand which means very odd e
but then we've got a map where we're
destructuring certain keys out of that
map in this case we're looking for port
and protocol and the way you can invoke
this is with F colon particle HTTP and
so what this is saying is that protocol
is a
optional key and so we could have put in
here F Colin port 1000 or we could put
in both options or we could put in
neither of the options and it would work
in either case you can also do structure
defaults from a map when you're
destructuring any map
if you want to destructor the defaults
of a map you can specify them with this
or form so you can specify if someone
doesn't pass in a port then I want to
use port 8080 if someone doesn't pass in
a protocol well I wouldn't use HTTP and
so this is the way that you do that but
it turns out that keyword arguments can
be fairly inconvenient the specific case
where they're inconvenient is if you
have a map already and then you want to
call the function it's a little bit
tricky figuring out well how do I
actually convert this map into something
that I can call the function with
because as you saw here this kind of
this flattened key value pair form that
we need to create so in this case I'm
slurping in some configuration from an
even file maybe it's got you know the
port and the protocol in there and then
I want to I want to actually call my
function there is a way to do it I think
you'll agree this looks a little bit
tricky to think about so I'll explain
what it's doing config is a map and
apply concat is concatenating sequences
together now a map can be considered to
be a sequence of key value pairs so if
you apply concat to the config it
produces what we need which is the key
value key value key value just as a
sequence but that's not what the
argument of F is f needs to be called
with those as the direct arguments not a
sequence of them and so we need to apply
F to that sequence and the result of
that is essentially F key value key
value key value
so all of that is doable but it's quite
confusing and we'd be way better off if
instead we just called F with the map so
to me this is a much more pleasing way
of calling our function we just pass in
the map we want so we should define F to
explicitly take a map of import
arguments and it's really not that
inconvenient to call F wrapped in a map
when I know what those are up front and
it's definitely very much more
convenient when I've slept in a map for
instance when you define a function it
is possible to set up some pre and post
conditions if you want pre and post
conditions you need to specify a map
after the argument list with pre and
post keys in it
they should be sequences of assertions
so in this case the precondition is a
sequence of one assertion the assertions
is that X is positive notice that for
the post condition you need to use the
percent symbol this will be the return
result unfortunately the syntax for pre
and post conditions is pretty easy to
get wrong for instance if you don't and
give a sequence of assertions it's
possible that no assertion will be made
it's also possible at runtime that their
sessions are disabled you also have
slightly less control over how our
reporting and handling is done so for
these reasons pre and post conditions
are pretty rarely used it seems to be
more common to actually check for a
condition and throw an explicit
exception in this example we're actually
checking the inputs and throwing an
exception if there's a problem and
similarly for the result we're checking
it and throwing exception if there's a
problem with that it's becoming more
popular now to use spec which we'll
cover more in detail later
so you've already seen that functions
can be defined in line they're called
function literals I just want to show
you here that you can specify multiple
argument in line literals for instance
if you use percent one percent to means
that this function takes two arguments
you can use as many as you want if you
want to you can create a very attic
inline function as well using this
percent ampersand form function literals
are a terse and useful but personally I
prefer to use the FN form as much as
possible in this case we can use the FN
form to give a name to what we're doing
here we're squaring the numbers and it's
going to show up in the stack traces if
there's any kind of an exception here
but ultimately it's just a preference
thing feel free to use either now it's a
great time to pause the video and take a
look at the exercises at the end of
section 3 of the manual ok let's check
out the answers we can define the square
function and call it with 55 to get 3025
we can define a square of square
function which actually calls a
previously defined square function on
the result of squaring the input so it's
the square of the square we additionally
checks the input range if X is less than
100 we do the square of the square if
it's outside of that range then we throw
an exception saying that the input is
too large so if we try this with a few
values we see that the square of square
of 2 is 16 and the square of square of
123 is too large so we get the exception
we can create a function that as a
single Fibonacci step a Fibonacci step
takes in two numbers and produces the
next two numbers in the sequence the
Fibonacci sequence is 1 1 2 3 5
where it's adding together the last two
numbers in the sequence we want the
result of one one to be one two
the result of one two to be two three
and the way we do that is we say the
first argument we need to add with the
second argument and that's going to be
the second element in the resulting
sequence and the existing second
argument is going to become the first so
this produces the next part of the
sequence in the manual the next section
is a challenge which encourages to use
what you've learned to build something a
little bit bigger so it'd be great if
you could take a crack of that and see
how you go
